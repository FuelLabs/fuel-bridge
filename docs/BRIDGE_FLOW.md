# Bridge flow

This document attempts to be a high level overview of how Fuel 's token bridge is operating currently.

## Concepts

To understand this document, it is useful to first get a grasp of a few concepts that will be referred to in the rest of this description.

- Layer 1 (L1): An EVM blockchain, namely Ethereum.
- Layer 2 (L2): The Fuel blockchain will sometimes be referred as the Layer 2 or L2.
- Fuel block: a block of the Fuel blockchain, generated by a validator set. It contains transactions, but also messages, outgoing and relayed.
- Outgoing messages: Messages that are generated in the L1 blockchain that must be sent to L2 entities.
- Relayed messages: Messages that are generated in the L2 (Fuel) blockchain that must be sent to L1 entities.
- Fuel epoch: A group of Fuel blocks, packed toghether and identifier by the last block of the epoch.
- Fuel validators: Entities that validate Fuel blocks and keep the ledger going.
- L1 Commits: Transactions on the L1 that start the finalization process of a Fuel epoch.
- Finality: State of commits by which the commit cannot be changed, it is considered honest and immutable - final. When an epoch is committed, a clock starts. If the commit is correct, time will pass and the epoch will be final - it cannot be reverted or changed. If the commit is not correct, a nhonest party can challenge it.
- Block comitter: entity in charge of listening to finished epochs from the Fuel Blockchain and comitting these epochs to the `FuelChainState` contract.
- `FuelChainState` contract: L1 Smart contract that holds epoch information.
- `FuelMessagePortal` contract: L1 Smart contract that is able to validate relay messages from Fuel Blocks that have been committed to the state contract, and relays those messages to the corresponding entities in L1
- Layer 1 Bridge smart contract: L1 smart contract that holds L1 tokens. Upon user deposits, it generates an message for the L2 counterpart to mint the associated L2 token.
- Layer 2 Bridge smart contract: L2 (Fuel) smart contract that mints L2 tokens when receiving messsages from the L1 counterpart. Similarly, burns L2 tokens and generates a withdrawal message for the L1 contract to release L1 tokens to their rightful owner.
- Deposit: User action by which some L1 tokens are locked in the L1 bridge smart contracts, minting the same amount in the L2 chain.
- Withdrawal: User action by which some L2 tokens are burnt in the L2 bridge smart contracts, releasing the burnt amount in the L1 chain.

## Description

Fuel 's bridge system is built on a message protocol that allows to send (and receive) messages between entities located in two different blockchains, namely the L1 (Ethereum or EVM) and L2 (Fuel blockchain). The system features sending messages in both directions (L1 to L2, and L2 to L1), though the mechanism involved for each direction is different. It can be derived that if the entities receiving these messages are capable of interpreting them, some actions can be executed. 

In the case of the bridge system, there are two scenarios:
1. The deposit scenario: a L1 smart contract can send a message to another L2 smart contract upon receiving a deposit of tokens. The L2 smart contract will receive, process and validate this message, and mint an equivalent amount of tokens in the L2
2. The withdrawal scenario: the holder of L2 tokens can burn them, and in doing so, generate a message from the L2 smart contract to the L1 smart contract that held bridged tokens. The L1 smart contract can process the message and release the L1 tokens back to an address, defined in the message generated in the L2 by the user, and presumably controlled by this same user.

In the case of the deposit scenario, the message is relayed from the L1 to the L2 by the validator set of the Fuel blockchain. The withdrawal messages, on the other hand, are indirectly included in the commits that assert the finality of the Fuel blockchain in the L1, which means that once the history of the Fuel ledger is considered final, immutable and anchored to the L1, any user can execute withdrawal messages in the L1 blockchain.

### Block committing

The Fuel blockchain aims to be scalable, and thus is able to generate blocks at a faster rate than other blockchains, without compromising on its security. It does so by inheriting the security of the L1 it is anchored to. The mechanism allowing this is an hybrid optimistic-ZK rollup (WIP). Blocks generated in the Fuel blockchain are grouped in epochs (e.g. an epoch can group together 10800 blocks), and epochs are identified and summarized in the last block of said epoch. This block can be committed to the L1 blockchain with a transaction to the `FuelChainState` contract, and will be accepted optimistically (i.e. the commit is considered valid unless proven otherwise - validation of the blocks are not considered in the scope of this document). The commits will be registered with the timestamp of the L1 blockchain. Then, once a certain time period has passed, the commit (along with the block) will be considered final. 

![Block Committing](block_committing.png)

### L1 Deposit

The deposit process is straightforward: the user will send a transaction to deposit an asset in a L1 bridge contract, which will in turn emit a message through the `FuelMessagePortal` to be picked up by the Fuel blockchain 's validator set. These validators will make sure that the message is included in the next blocks of the Fuel blockchain. Message inclusion also carries the possibility of said message being processed by its recipient - in the case of L1 deposit, a message will be delivered from the L1 bridge contract to the L2 bridge contract. This last contract will have the capability of processing these messages, validating that their sender is the L1 bridge contract, and then proceeding to mint an equivalent asset and amount in the Fuel blockchain to the one originally depositted in the L1. Then, the minted assets become available to the user in the L2.

![L1 Deposit](l1_deposit.png)

You can follow the actual implementation of the message processing flow via:
- [FuelERC20Gateway.sol](../packages/portal-contracts/contracts/messaging/gateway/FuelERC20Gateway.sol) 's `deposit` function:
```js
function deposit(bytes32 to, address tokenId, bytes32 fuelTokenId, uint256 amount) external payable whenNotPaused {
    bytes memory messageData = abi.encodePacked(
        fuelTokenId,
        bytes32(uint256(uint160(tokenId))),
        bytes32(uint256(uint160(msg.sender))), //from
        to,
        bytes32(amount)
    );
    _deposit(tokenId, fuelTokenId, amount, messageData);
}
```

- [FuelMessagePortal.sol](../packages/portal-contracts/contracts/fuelchain/FuelMessagePortal.sol) 's `sendMessage` function:
```js
// From FuelMessagePortal.sol

///////////////////////////////////////
// Outgoing Message Public Functions //
///////////////////////////////////////

/// @notice Send a message to a recipient on Fuel
/// @param recipient The target message receiver address or predicate root
/// @param data The message data to be sent to the receiver
function sendMessage(bytes32 recipient, bytes memory data) external payable whenNotPaused {
    _sendOutgoingMessage(recipient, data);
}

/// @notice Send only ETH to the given recipient
/// @param recipient The target message receiver
function depositETH(bytes32 recipient) external payable whenNotPaused {
    _sendOutgoingMessage(recipient, new bytes(0));
}

////////////////////////
// Internal Functions //
////////////////////////

/// @notice Performs all necessary logic to send a message to a target on Fuel
/// @param recipient The message receiver address or predicate root
/// @param data The message data to be sent to the receiver
function _sendOutgoingMessage(bytes32 recipient, bytes memory data) private {
    bytes32 sender = bytes32(uint256(uint160(msg.sender)));
    unchecked {
        //make sure data size is not too large
        require(data.length < MAX_MESSAGE_DATA_SIZE, "message-data-too-large");

        //make sure amount fits into the Fuel base asset decimal level
        uint256 precision = 10 ** (ETH_DECIMALS - FUEL_BASE_ASSET_DECIMALS);
        uint256 amount = msg.value / precision;
        if (msg.value > 0) {
            require(amount * precision == msg.value, "amount-precision-incompatability");
            require(amount <= ((2 ** 64) - 1), "amount-precision-incompatability");
        }

        //emit message for Fuel clients to pickup (messageID calculated offchain)
        emit MessageSent(sender, recipient, _outgoingMessageNonce, uint64(amount), data);

        // increment nonce for next message
        ++_outgoingMessageNonce;
    }
}
```

- [bridge_fungible_token.sw](../packages/fungible-token/bridge-fungible-token/src/bridge_fungible_token.sw) 's `process_message` function:
```rs
// From bridge_fungible_token.sw

// Implement the process_message function required to be a message receiver
impl MessageReceiver for Contract {
    #[payable]
    #[storage(read, write)]
    fn process_message(msg_idx: u8) {
        // Protect against reentrancy attacks that could allow replaying messages
        reentrancy_guard();

        let input_sender = input_message_sender(msg_idx);
        require(input_sender.value == BRIDGED_TOKEN_GATEWAY, BridgeFungibleTokenError::UnauthorizedSender);

        let message_data = parse_message_data(msg_idx);
        require(message_data.amount != ZERO_B256, BridgeFungibleTokenError::NoCoinsSent);

        // register a refund if tokens don't match
        if (message_data.token != BRIDGED_TOKEN) {
            register_refund(message_data.from, message_data.token, message_data.amount);
            return;
        };

        let res_amount = adjust_deposit_decimals(message_data.amount, DECIMALS, BRIDGED_TOKEN_DECIMALS);

        match res_amount {
            Result::Err(_) => {
                // register a refund if value can't be adjusted
                register_refund(message_data.from, message_data.token, message_data.amount);
            },
            Result::Ok(amount) => {
                // mint tokens & update storage
                mint(amount);
                match storage.tokens_minted.try_read() {
                    Option::Some(value) => storage.tokens_minted.write(value + amount),
                    Option::None => storage.tokens_minted.write(amount),
                };

                // when depositing to an address, msg_data.len is 160 bytes.
                // when depositing to a contract, msg_data.len is 161 bytes.
                // If msg_data.len is > 161 bytes, we must call `process_message()` on the receiving contract, forwarding the newly minted coins with the call.
                match message_data.len {
                    160 => {
                        transfer(amount, contract_id(), message_data.to);
                    },
                    161 => {
                        transfer(amount, contract_id(), message_data.to);
                    },
                    _ => {
                        if let Identity::ContractId(id) = message_data.to {
                            let dest_contract = abi(MessageReceiver, id.into());
                            dest_contract.process_message {
                                coins: amount,
                                asset_id: contract_id().value,
                            }(msg_idx);
                        };
                    },
                }

                log(DepositEvent {
                    to: message_data.to,
                    from: message_data.from,
                    amount: amount,
                });
            }
        }
    }
}
```

### L2 (Fuel) Withdrawal

The withdrawal message can be more convoluted, bear with us. The user will start the process by signaling a withdrawal transaction to the [L2 Bridge Contract](../packages/fungible-token/bridge-fungible-token/src/bridge_fungible_token.sw), which will burn the tokens and generate a message to be relayed from the L2 to the L1, with recipient to the [L1 Bridge Contract](../packages/portal-contracts/contracts/messaging/gateway/FuelERC20Gateway.sol). This message will be relayed later on by means of the block committer and the [Message Portal](../packages/portal-contracts/contracts/fuelchain/FuelMessagePortal.sol). 

Once the transaction has been included in the Fuel blockchain, the user will need to await two events:
- First, the Fuel blockchain will need to close an epoch. The epoch will be committed to the L1 blockchain in the [Chain State contract](../packages/portal-contracts/contracts/fuelchain/FuelChainState.sol).
- Then, once the epoch has been committed, it is needed to wait for its finalization.

After finality has been reached for the epoch that includes the block where the withdrawal transaction was signaled, the user can request the proofs of inclusion of the transaction and message in the block epoch that was comitted to the L1. The user will send a transaction call to the [Message Portal](../packages/portal-contracts/contracts/fuelchain/FuelMessagePortal.sol) 's `relayMessage` function that will check the attached proofs and the finalization status of the epoch that the message belongs to, then proceed to unpack the payload of said message, that should contain an execution instruction to call `finalizeWithdrawal` in  the [L1 Bridge Contract](../packages/portal-contracts/contracts/messaging/gateway/FuelERC20Gateway.sol), releasing the L1 locked tokens.

![L2 Withdrawal](l2_withdrawal.png)

You can follow the implementation of this flow via:
- [bridge_fungible_token.sw](../packages/fungible-token/bridge-fungible-token/src/bridge_fungible_token.sw) 's `withdraw` function:
```rs
fn withdraw(to: b256) {
    let amount = msg_amount();
    let origin_contract_id = msg_asset_id();
    require(amount != 0, BridgeFungibleTokenError::NoCoinsSent);
    require(origin_contract_id == contract_id(), BridgeFungibleTokenError::IncorrectAssetDeposited);

    // attempt to adjust amount into base layer decimals and burn the sent tokens
    let adjusted_amount = adjust_withdrawal_decimals(amount, DECIMALS, BRIDGED_TOKEN_DECIMALS).unwrap();
    storage.tokens_minted.write(storage.tokens_minted.read() - amount);
    burn(amount);

    // send a message to unlock this amount on the base layer gateway contract
    let sender = msg_sender().unwrap();
    send_message(BRIDGED_TOKEN_GATEWAY, encode_data(to, adjusted_amount, BRIDGED_TOKEN), 0);
    log(WithdrawalEvent {
        to: to,
        from: sender,
        amount: amount,
    });
}
```
- [FuelChainState.sol](../packages/portal-contracts/contracts/fuelchain/FuelChainState.sol) 's `commit` and `finalized` functions:
```js
function commit(bytes32 blockHash, uint256 commitHeight) external whenNotPaused onlyRole(COMMITTER_ROLE) {
    uint256 slot = commitHeight % NUM_COMMIT_SLOTS;
    Commit storage commitSlot = _commitSlots[slot];
    commitSlot.blockHash = blockHash;
    commitSlot.timestamp = uint32(block.timestamp);

    emit CommitSubmitted(commitHeight, blockHash);
}

function finalized(bytes32 blockHash, uint256 blockHeight) external view whenNotPaused returns (bool) {
    // TODO This division could be done offchain, or at least also could be assembly'ed to avoid non-zero division check
    uint256 commitHeight = blockHeight / BLOCKS_PER_COMMIT_INTERVAL;
    Commit storage commitSlot = _commitSlots[commitHeight % NUM_COMMIT_SLOTS];
    require(commitSlot.blockHash == blockHash, "Unknown block");

    return block.timestamp >= uint256(commitSlot.timestamp) + TIME_TO_FINALIZE;
}
```
- [Message Portal](../packages/portal-contracts/contracts/fuelchain/FuelMessagePortal.sol) 's `relayMessage` function:
```js
function relayMessage(
    Message calldata message,
    FuelBlockHeaderLite calldata rootBlockHeader,
    FuelBlockHeader calldata blockHeader,
    MerkleProof calldata blockInHistoryProof,
    MerkleProof calldata messageInBlockProof
) external payable whenNotPaused {
    //verify root block header
    require(
        _fuelChainState.finalized(rootBlockHeader.computeConsensusHeaderHash(), rootBlockHeader.height),
        "Unfinalized root block"
    );

    //verify block in history
    require(
        verifyBinaryTree(
            rootBlockHeader.prevRoot,
            abi.encodePacked(blockHeader.computeConsensusHeaderHash()),
            blockInHistoryProof.proof,
            blockInHistoryProof.key,
            rootBlockHeader.height
        ),
        "Invalid block in history proof"
    );

    //verify message in block
    bytes32 messageId = CryptographyLib.hash(
        abi.encodePacked(message.sender, message.recipient, message.nonce, message.amount, message.data)
    );
    require(
        verifyBinaryTree(
            blockHeader.outputMessagesRoot,
            abi.encodePacked(messageId),
            messageInBlockProof.proof,
            messageInBlockProof.key,
            blockHeader.outputMessagesCount
        ),
        "Invalid message in block proof"
    );

    //execute message
    _executeMessage(messageId, message);
}
```
- [FuelERC20Gateway.sol](../packages/portal-contracts/contracts/messaging/gateway/FuelERC20Gateway.sol) 's `finalizeWithdrawal`:
```js
function finalizeWithdrawal(
    address to,
    address tokenId,
    uint256 amount
) external payable whenNotPaused onlyFromPortal {
    require(amount > 0, "Cannot withdraw zero");
    bytes32 fuelTokenId = messageSender();

    //reduce deposit balance and transfer tokens (math will underflow if amount is larger than allowed)
    _deposits[tokenId][fuelTokenId] = _deposits[tokenId][fuelTokenId] - amount;
    IERC20Upgradeable(tokenId).safeTransfer(to, amount);

    //emit event for successful token withdraw
    emit Withdrawal(bytes32(uint256(uint160(to))), tokenId, fuelTokenId, amount);
}
```